%{
#include <string>
#include <iostream>

#include "lexer.h"

#ifdef yylex
#undef yylex
#endif
#define yylex lexer.lex

%}

%parse-param { struct lexer_t & lexer }
%locations

%name-prefix "ast"

%union {
    int integer;
    bool boolean;
    std::string * string;
    Code * code;
    CodeEntry * code_entry;
    Declaration * declaration;
    Definition * definition;
    VarDeclaration * var_declaration;
    FuncDeclaration * fun_declaration;
    VarDefinition * var_definition;
    FuncDefinition * fun_definition;
    Type * type;
    std::list<VarDeclaration> * args;
    Statement * statement;
}

%token              END         0   "end of file"
%token              SEMICOLON
%token              LPAREN
%token              RPAREN
%token              COMMA
%token              CLPAREN
%token              CRPAREN
%token              ASSIGN
%token              EXTERN
%token              IF
%token              ELSE
%token              WHILE
%token              READ
%token              WRITE
%token              PLUS
%token              MINUS
%token              MULT
%token              DIV
%token              MOD
%token              LT
%token              GT
%token              EQ
%token              LE
%token              GE
%token              NE
%token              AND
%token              OR
%token              INTEGER_TYPE
%token              BOOLEAN_TYPE
%token              TRUE
%token              FALSE
%token  <integer>   INTEGER
%token  <string>    NAME

%type   <code>              prog
%type   <code_entry>        prog_item
%type   <declaration>       declaration
%type   <var_declaration>   var_declaration var_def
%type   <fun_declaration>   fun_declaration fun_signature
%type   <args>              args args_tail
%type   <definition>        definition
%type   <fun_definition>    fun_def
%type   <type>              type
%type   <string>            name
%type   <statement>         statement
%type   <boolean>           bool
%type   <integer>           int

%%

prog:
          /* empty */       { $$ = new Code(); }
        | prog_item prog    { $2->entries.push_back(*$1); $$ = $2; }
        ;

prog_item:
          declaration       { $$ = new CodeEntry(*$1); }
        | definition        { $$ = new CodeEntry(*$1); }
        ;

declaration:
          var_declaration   { $$ = new Declaration(*$1); }
        | fun_declaration   { $$ = new Declaration(*$1); }
        ;

definition:
          var_def SEMICOLON { $$ = new Definition(*$1); }
        | fun_def           { $$ = new Definition(*$1); }
        ;

var_declaration:
          EXTERN type name SEMICOLON { $$ = new VarDeclaration{*$2, *$3}; }
        ;

fun_declaration:
          fun_signature SEMICOLON { $$ = $1; }
        ;

fun_signature:
          type name LPAREN args RPAREN { $$ = new FuncDeclaration{*$1, *$2, *$4}; }
        ;
          
args:
          /* empty */           { $$ = new std::list<VarDeclaration>; }
        | type name args_tail   { $3->push_front({*$1, *$2}); $$ = $3; }
        ;

args_tail:
          /* empty */               { $$ = new std::list<VarDeclaration>; }
        | COMMA type name args_tail { $4->push_front({*$2, *$3}); $$ = $4; }
        ;

var_def:
          type name { $$ = new VarDeclaration{*$1, *$2}; }
        ;

fun_def:
          fun_signature CLPAREN statement CRPAREN { $$ = new FuncDefinition{*$1, *$3}; }
        ;

statement:
          /* empty */   { std::cout << "skip" << std::endl; }
        | var_def       { std::cout << "var def" << std::endl; }
        | name ASSIGN expr  { std::cout << "name = expr" << std::endl; }
        | statement SEMICOLON statement {}
        | IF LPAREN expr RPAREN statement ELSE statement {}
        | CLPAREN statement CRPAREN {}
        | WHILE LPAREN expr RPAREN statement {}
        | READ LPAREN name RPAREN {}
        | WRITE LPAREN expr RPAREN {}
        ;

expr:
          bool
        | int
        | name
        | expr operator expr
        ;

operator:
          PLUS
        | MINUS
        | MULT
        | DIV
        | MOD
        | LT
        | GT
        | EQ
        | LE
        | GE
        | NE
        | AND
        | OR
        ;

type:
          INTEGER_TYPE  { std::cout << "int" << std::endl; }
        | BOOLEAN_TYPE  { std::cout << "_Bool" << std::endl; }
        ;

name:
          NAME          { $$ = $1; }
        ; 

bool:
          TRUE          { $$ = true; }
        | FALSE         { $$ = false; }
        ;

int     :
          INTEGER       { $$ = $1; }
        ;
